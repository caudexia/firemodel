{"version":3,"sources":["../../src/client/index.ts","../../src/BaseModel.ts"],"sourcesContent":["import * as firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { ZodSchema, ZodTypeDef } from 'zod';\nimport { createModel } from '../BaseModel';\nimport {\n  getDoc,\n  doc,\n  getFirestore,\n  addDoc,\n  collection,\n  updateDoc,\n  deleteDoc,\n  onSnapshot,\n  Query,\n} from 'firebase/firestore';\n\ninterface FirebaseConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  storageBucket: string;\n  messagingSenderId: string;\n  appId: string;\n  measurementId?: string;\n}\n\nexport interface DocUpdate {\n  id: string;\n  data: Record<number | string | symbol, any>;\n  exists: boolean;\n};\n\n/**\n * Initializes the firemodel package with the given Firestore instance for web.\n * \n * @param {FirebaseConfig} config - Firestore config for web.\n */\nexport const initializeWeb = (config: FirebaseConfig) => {\n  // Initialize Firebase\n  if (!firebase.getApps().length) {\n    firebase.initializeApp(config);\n  } else {\n    firebase.getApp();\n  }\n\n  // Initialize Firestore\n  const firestore = getFirestore();\n\n  // You can add more configurations here, such as enabling offline support\n  // firestore.enablePersistence()\n  //   .catch((err) => {\n  //     console.error(\"Firestore persistence error:\", err);\n  //   });\n\n  return firestore;\n};\n\n/**\n * Creates a web model with methods tailored for the Firebase Web SDK.\n * \n * @template IInput - The type of the data model used for input (to be validated).\n * @template IOutput - The type of the data model used for output (to be returned).\n * @param {string} collectionName - The name of the Firestore collection.\n * @param {ZodSchema<IOutput, ZodTypeDef, IInput>} schema - The Zod schema for data validation.\n * @returns {ReturnType<typeof createModel<IInput, IOutput>>} - The methods associated with the web model.\n */\nexport const createWebModel = <IInput, IOutput>(collectionName: string, schema: ZodSchema<IOutput, ZodTypeDef, IInput>) => {\n  const baseModel = createModel(collectionName, schema);\n\n  return {\n      ...baseModel,\n\n    /**\n     * Fetches a document by its ID.\n     * \n     * @param {string} id - The ID of the document to fetch.\n     * @returns {Promise<IOutput | undefined>} - The fetched document or undefined if not found.\n     */\n    async get(id: string): Promise<IOutput | undefined> {\n      const docSnap = await getDoc(doc(getFirestore(), collectionName, id));\n\n      if (docSnap.exists()) {\n        return baseModel.validate(docSnap.data() as IInput);\n      }\n\n      return undefined;\n    },\n\n    /**\n     * Adds a new document to the collection.\n     * \n     * @param {IInput} data - The data of the document to add.\n     * @returns {Promise<string>} - The ID of the added document.\n     */\n    async add(data: IInput): Promise<string> {\n      const validatedData = baseModel.validate(data);\n\n      if (!validatedData) {\n        throw new Error('firemodel: Validation failed for the provided data.');\n      }\n\n      const docRef = await addDoc(collection(getFirestore(), collectionName), validatedData);\n      return docRef.id;\n    },\n\n    /**\n     * Updates an existing document in the collection.\n     * \n     * @param {string} id - The ID of the document to update.\n     * @param {Partial<IInput>} data - The data to update in the document.\n     * @returns {Promise<void>} - Resolves when the update is successful.\n     * @throws {Error} - Throws an error if validation fails or if other issues arise during the update.\n     */\n    async update(id: string, data: Partial<IInput>): Promise<void> {\n      const validatedData = baseModel.validate(data);\n\n      if (!validatedData) {\n        throw new Error('firemodel: Validation failed for the provided data.');\n      }\n\n      // https://github.com/googleapis/nodejs-firestore/issues/1745\n      await updateDoc(doc(getFirestore(), collectionName, id), validatedData as any);\n    },\n\n    /**\n     * Deletes a document from the collection by its ID.\n     * \n     * @param {string} id - The ID of the document to delete.\n     * @returns {Promise<void>} - Resolves when the deletion is successful.\n     * @throws {Error} - Throws an error if issues arise during the deletion.\n     */\n    async delete(id: string): Promise<void> {\n      await deleteDoc(doc(getFirestore(), collectionName, id));\n    },\n\n    /**\n     * Subscribes to real-time updates for the collection. Whenever data in the collection changes,\n     * the provided callback is invoked with the updated set of documents.\n     * \n     * @param {function(Array<{ data: IOutput } & DocUpdate>): void} callback - The function to call with the updated documents.\n     * @param {function(query: typeof Query): typeof Query} [queryFn] - \n     *        An optional function to modify or filter the base query.\n     * @returns {function(): void} - A function to unsubscribe from the real-time updates.\n     * @throws {Error} - Throws an error if issues arise during the subscription.\n     */\n    subscribeToRealtimeUpdates(\n      callback: (items: Array<{ data: IOutput } & DocUpdate>) => void,\n      queryFn?: (query: Query) => Query,\n    ) {\n      let baseQuery: Query = collection(getFirestore(), collectionName);\n\n      if (queryFn) {\n        baseQuery = queryFn(baseQuery);\n      }\n\n      return onSnapshot(baseQuery, snapshot => {\n        const items: Array<{ data: IOutput } & DocUpdate> = [];\n\n        snapshot.forEach(docSnap => {\n          const data = docSnap.data();\n          const validatedData = baseModel.validate(data as IInput);\n\n          if (validatedData) {\n            items.push({\n              id: docSnap.id,\n              data: validatedData,\n              exists: docSnap.exists(),\n            });\n          }\n        });\n\n        callback(items);\n      });\n    },\n  };\n};\n","import { ZodSchema, ZodTypeDef } from 'zod';\n\ninterface ModelMethods<IInput, IOutput> {\n  validate: (data: Partial<IInput>) => IOutput | undefined;\n  get: (id: string) => Promise<IOutput | undefined>;\n  add: (data: IInput) => Promise<string>;\n  update: (id: string, data: Partial<IInput>) => Promise<void>;\n  delete: (id: string) => Promise<void>;\n}\n\n/**\n * Creates a base model with common methods for data validation and manipulation.\n * \n * @template IInput - The type of the data model used for input.\n * @template IOutput - The type of the data model used for output.\n * @param {string} _collectionName - The name of the Firestore collection.\n * @param {ZodSchema<IInput>} schema - The Zod schema for data validation.\n * @returns {ModelMethods<IInput, IOutput>} - The methods associated with the model.\n */\nexport function createModel<IInput, IOutput>(_collectionName: string, schema: ZodSchema<IOutput, ZodTypeDef, IInput>): ModelMethods<IInput, IOutput> {\n  return {\n    validate(data: Partial<IInput>): IOutput | undefined {\n      try {\n        return schema.parse(data);\n      } catch (error) {\n        return undefined;\n      }\n    },\n    async get(_id: string): Promise<IOutput | undefined> {\n      throw new Error(\"Method not implemented.\");\n    },\n    async add(_data: IInput): Promise<string> {\n      throw new Error(\"Method not implemented.\");\n    },\n    async update(_id: string, _data: Partial<IInput>): Promise<void> {\n      throw new Error(\"Method not implemented.\");\n    },\n    async delete(_id: string): Promise<void> {\n      throw new Error(\"Method not implemented.\");\n    },\n  };\n}\n"],"mappings":"0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,oBAAAE,EAAA,kBAAAC,IAAA,eAAAC,EAAAJ,GAAA,IAAAK,EAA0B,2BAC1BC,EAAO,8BCkBA,SAASC,EAA6BC,EAAyBC,EAA+E,CACnJ,MAAO,CACL,SAASC,EAA4C,CACnD,GAAI,CACF,OAAOD,EAAO,MAAMC,CAAI,CAC1B,MAAgB,CACd,MACF,CACF,EACA,MAAM,IAAIC,EAA2C,CACnD,MAAM,IAAI,MAAM,yBAAyB,CAC3C,EACA,MAAM,IAAIC,EAAgC,CACxC,MAAM,IAAI,MAAM,yBAAyB,CAC3C,EACA,MAAM,OAAOD,EAAaC,EAAuC,CAC/D,MAAM,IAAI,MAAM,yBAAyB,CAC3C,EACA,MAAM,OAAOD,EAA4B,CACvC,MAAM,IAAI,MAAM,yBAAyB,CAC3C,CACF,CACF,CDrCA,IAAAE,EAUO,8BAuBMC,EAAiBC,IAEd,UAAQ,EAAE,OAGb,SAAO,EAFP,gBAAcA,CAAM,KAMb,gBAAa,GAoBpBC,EAAiB,CAAkBC,EAAwBC,IAAmD,CACzH,IAAMC,EAAYC,EAAYH,EAAgBC,CAAM,EAEpD,MAAO,CACH,GAAGC,EAQL,MAAM,IAAIE,EAA0C,CAClD,IAAMC,EAAU,QAAM,aAAO,UAAI,gBAAa,EAAGL,EAAgBI,CAAE,CAAC,EAEpE,GAAIC,EAAQ,OAAO,EACjB,OAAOH,EAAU,SAASG,EAAQ,KAAK,CAAW,CAItD,EAQA,MAAM,IAAIC,EAA+B,CACvC,IAAMC,EAAgBL,EAAU,SAASI,CAAI,EAE7C,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,qDAAqD,EAIvE,OADe,QAAM,aAAO,iBAAW,gBAAa,EAAGP,CAAc,EAAGO,CAAa,GACvE,EAChB,EAUA,MAAM,OAAOH,EAAYE,EAAsC,CAC7D,IAAMC,EAAgBL,EAAU,SAASI,CAAI,EAE7C,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,qDAAqD,EAIvE,QAAM,gBAAU,UAAI,gBAAa,EAAGP,EAAgBI,CAAE,EAAGG,CAAoB,CAC/E,EASA,MAAM,OAAOH,EAA2B,CACtC,QAAM,gBAAU,UAAI,gBAAa,EAAGJ,EAAgBI,CAAE,CAAC,CACzD,EAYA,2BACEI,EACAC,EACA,CACA,IAAIC,KAAmB,iBAAW,gBAAa,EAAGV,CAAc,EAEhE,OAAIS,IACFC,EAAYD,EAAQC,CAAS,MAGxB,cAAWA,EAAWC,GAAY,CACvC,IAAMC,EAA8C,CAAC,EAErDD,EAAS,QAAQN,GAAW,CAC1B,IAAMC,EAAOD,EAAQ,KAAK,EACpBE,EAAgBL,EAAU,SAASI,CAAc,EAEnDC,GACFK,EAAM,KAAK,CACT,GAAIP,EAAQ,GACZ,KAAME,EACN,OAAQF,EAAQ,OAAO,CACzB,CAAC,CAEL,CAAC,EAEDG,EAASI,CAAK,CAChB,CAAC,CACH,CACF,CACF","names":["client_exports","__export","createWebModel","initializeWeb","__toCommonJS","firebase","import_firestore","createModel","_collectionName","schema","data","_id","_data","import_firestore","initializeWeb","config","createWebModel","collectionName","schema","baseModel","createModel","id","docSnap","data","validatedData","callback","queryFn","baseQuery","snapshot","items"]}